# Cryptography/椭圆曲线签名与验签

这节介绍椭圆曲线签名算法(Elliptic Curve Digital Signature Algorithm, ECDSA)与其验签步骤. 其实你既然在搜索引擎中找到了我这篇文章我更推荐你直接看原始论文的第 7 章, 链接 <https://www.cs.miami.edu/home/burt/learning/Csc609.142/ecdsa-cert.pdf>.

## 签名

0. 令 z 为待签名信息. 通常是原信息的哈希值.
0. 使用私钥 e 生成公钥 P, 即 `e * G = P`.
0. 使用一个随机生成的一次性私钥 k 生成公钥 R, 即 `k * G = R`.
0. 令 r 为 R 的 x 轴坐标.
0. `s = (z + r * e) / k`.
0. `(r, s)` 即为 z 的签名.

> ECDSA 十分依赖 k 的随机性. 绝对不能在不同的签名中使用相同的 k. 在两个签名中使用相同的 k, 可以逆推出私钥.

## 验签

0. 令 `u = z / s`, `v = r / s`.
0. 令 `R = u * G + v * P`.
0. 判断 R 的 x 轴坐标是否等于 r.

## 代码实现

```py
import random
import secp256k1

prikey = 0x5f6717883bef25f45a129c11fcac1567d74bda5a9ad4cbffc8203c0da2a1473c
pubkey = secp256k1.G * prikey

# Hash of messages. Generated by "sha256sum secp256k1.py"
z = 0x72a963cdfb01bc37cd283106875ff1f07f02bc9ad6121b75c3d17629df128d4e
print(f'hash=0x{z:064x}')

# Sign
while True:
    e = prikey
    k = random.randint(0, secp256k1.N)
    R = secp256k1.G * k
    r = R.x.x % secp256k1.N
    if r == 0:
        continue
    k_inv = pow(k, -1, secp256k1.N)
    s = ((z + r*e) * k_inv) % secp256k1.N
    if s == 0:
        continue
    print(f'sigr=0x{r:064x}')
    print(f'sigs=0x{s:064x}')
    break

# Verify
s_inv = pow(s, -1, secp256k1.N)
u = (z * s_inv) % secp256k1.N
v = (r * s_inv) % secp256k1.N
assert (secp256k1.G * u + pubkey * v).x.x == r
print('pass')
```

## 参考

- [1] onyb: ECDSA <https://onyb.gitbook.io/secp256k1-python/ecdsa>
- [2] Don Johnson, Alfred Menezes and Scott Vanstone, The Elliptic Curve Digital Signature Algorithm (ECDSA) <https://www.cs.miami.edu/home/burt/learning/Csc609.142/ecdsa-cert.pdf>
